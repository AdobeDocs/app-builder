"use strict";(self.webpackChunkadobe_developer_app_builder=self.webpackChunkadobe_developer_app_builder||[]).push([[9263],{83557:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return l},default:function(){return p}});var o=t(87462),a=t(63366),r=(t(15007),t(64983)),i=t(91515),s=["components"],l={},u={_frontmatter:l},d=i.Z;function p(e){var n=e.components,t=(0,a.Z)(e,s);return(0,r.mdx)(d,(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"consume-events-using-journaling-api"},"Consume Events Using Journaling API"),(0,r.mdx)("p",null,"This codelab will guide you through creating cron jobs in an App Builder application to consume events using journaling API"),(0,r.mdx)("h2",{id:"user-story"},"User Story"),(0,r.mdx)("p",null,"There is a class of App Builder apps in which customers want guarantees that the I/O Events are processed without losing any event especially\nwhen there is a surge of events, a runtime webhook would return 429 response beyond the concurrency limit, thereby causing the webhook to be\nmarked unreachable and causing no further events to be delivered. In this use case, the journaling API of custom events would be useful here. "),(0,r.mdx)("h2",{id:"solution"},"Solution"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Using ",(0,r.mdx)("a",{parentName:"li",href:"/app-builder/events/docs/guides/api/journaling_api/"},"Journaling API")," to retrieve the events instead of relying on the webhook approach."),(0,r.mdx)("li",{parentName:"ul"},"Use a runtime action that uses the ",(0,r.mdx)("a",{parentName:"li",href:"../cron-jobs/index.md"},"Alarm package")," to read the events every X minutes."),(0,r.mdx)("li",{parentName:"ul"},"The alarm action stores the events in the App Builder storage ",(0,r.mdx)("a",{parentName:"li",href:"https://github.com/adobe/aio-lib-state"},"aio-lib-state"),"."),(0,r.mdx)("li",{parentName:"ul"},"Index of events has been recorded in storage that if the action fails, the next invocation will retrieve from the same index, thus no events are lost.")),(0,r.mdx)("p",null,"In order to demo how to using journaling API to consume events, we provide an end to end solution in this codelab, "),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Event provider - we need to create an event provider to automatically generate events sending to Journaling API or if you already have event provider you could skip this step"),(0,r.mdx)("li",{parentName:"ul"},"Event consumer - which is the main demo part of this codelab, we create another App Builder headless app to create cron jobs with alarms, we set up recurring jobs to pull from journaling API every x mins and write into App Builder storage.")),(0,r.mdx)("p",null,"Event provider and event consumer both need to be deployed as an App Builder app under different namespace to make sure end to end workflow.\nSo for that purpose, you may need to create two projects at Console follow below:\n",(0,r.mdx)("a",{parentName:"p",href:"../../getting_started/first_app.md"},"Creating your First App Builder Application")),(0,r.mdx)("p",null,"If successfully set up, you should be able to see your event consumer will periodically pull events from journaling API and write into storage.\nFor your convenience, we provide a complete solution of this codelab at ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/AdobeDocs/adobeio-samples-journaling-events"},"here")))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-resources-journaling-events-index-md-ea6e0964b3b4963f03fb.js.map