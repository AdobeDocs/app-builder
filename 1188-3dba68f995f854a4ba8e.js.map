{"version":3,"file":"1188-3dba68f995f854a4ba8e.js","mappings":"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","sources":["webpack://adobe-developer-app-builder/./node_modules/penpal/lib/enums.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/getOriginFromSrc.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/errorSerialization.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/generateId.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/methodSerialization.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/connectCallSender.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/handleAckMessageFactory.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/connectCallReceiver.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/monitorIframeRemoval.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/connectToChild.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/createLogger.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/createDestructor.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/parent/handleSynMessageFactory.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/startConnectionTimeout.js","webpack://adobe-developer-app-builder/./node_modules/penpal/lib/child/connectToParent.js","webpack://adobe-developer-app-builder/./node_modules/@adobe/gatsby-theme-aio/src/components/Frame/index.js"],"sourcesContent":["export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        // Under specific timing circumstances, we can receive an event\n        // whose source is null. This seems to happen when the child iframe is\n        // removed from the DOM about the same time it has sent the SYN event.\n        // https://github.com/Aaronius/penpal/issues/85\n        if (!event.source) {\n            return;\n        }\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","import createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport { MessageType, NativeEventType } from '../enums';\nimport handleSynAckMessageFactory from './handleSynAckMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport startConnectionTimeout from '../startConnectionTimeout';\nconst areGlobalsAccessible = () => {\n    try {\n        clearTimeout();\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\n/**\n * Attempts to establish communication with the parent window.\n */\nexport default (options = {}) => {\n    const { parentOrigin = '*', methods = {}, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Child', log);\n    const { destroy, onDestroy } = destructor;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);\n    const sendSynMessage = () => {\n        log('Child: Handshake - Sending SYN');\n        const synMessage = { penpal: MessageType.Syn };\n        const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;\n        window.parent.postMessage(synMessage, parentOriginForSyn);\n    };\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            // Under niche scenarios, we get into this function after\n            // the iframe has been removed from the DOM. In Edge, this\n            // results in \"Object expected\" errors being thrown when we\n            // try to access properties on window (global properties).\n            // For this reason, we try to access a global up front (clearTimeout)\n            // and if it fails we can assume the iframe has been removed\n            // and we ignore the message event.\n            if (!areGlobalsAccessible()) {\n                return;\n            }\n            if (event.source !== parent || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.SynAck) {\n                const callSender = handleSynAckMessage(event);\n                if (callSender) {\n                    window.removeEventListener(NativeEventType.Message, handleMessage);\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        sendSynMessage();\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, { useContext, useRef, useEffect, useState } from 'react';\nimport { withPrefix } from 'gatsby';\nimport { css } from '@emotion/react';\nimport { connectToChild } from 'penpal';\nimport { Footer } from '../Footer';\nimport PropTypes from 'prop-types';\nimport Context from '../Context';\nimport { isExternalLink } from '../../utils';\n\nconst Frame = ({ src, height = 'calc(100vh - var(--spectrum-global-dimension-size-800))', location }) => {\n  const iframe = useRef(null);\n  // some strangeness with ims not being set within context???\n  const { ims, isLoadingIms } = useContext(Context);\n  let imsHack;\n  const [child, setChild] = useState(null);\n\n  // ensures connectToChild is called before the child calls connectToParent\n  const [connectionReady, setConnectionReady] = useState(false);\n\n  useEffect(() => {\n    if (child) {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n    }\n  }, [location.pathname]);\n\n  useEffect(() => {\n    setConnectionReady(false);\n    if (iframe != null && !isLoadingIms) {\n\n      // TODO: figure out why ims from context is not being updated so have to use a hacky solution like this\n      imsHack = window.adobeIMS;\n      const connection = createConnection();\n\n      return () => {\n        connection.destroy();\n      };\n    }\n  }, [iframe, isLoadingIms]);\n\n  const iframeSrc = isExternalLink(src) ? src : withPrefix(src);\n\n  const createConnection = () => {\n    const connection = connectToChild({\n      // The iframe to which a connection should be made\n      iframe: iframe.current,\n      // Manually set origin as auto-detection may fail, as the src of the iframe is set later\n      childOrigin: isExternalLink(src) ? new URL(src).origin : window.origin,\n      // Methods the parent is exposing to the child\n      methods: {\n        scrollTop(position = 0) {\n          if (document?.scrollingElement) {\n            document.scrollingElement.scrollTop = position;\n          }\n        },\n        getURL() {\n          return window?.location?.href;\n        },\n        setURL(url) {\n          if (window?.location) {\n            window.location = url;\n          }\n        },\n        setHeight(height) {\n          iframe.current.style.height = height;\n        },\n        getIMSAccessToken() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getAccessToken();\n          }\n\n          return null;\n        },\n        getIMSProfile() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getProfile();\n          }\n\n          return null;\n        },\n        signIn() {\n          if (imsHack && !imsHack.isSignedInUser()) {\n            imsHack.signIn();\n          }\n        },\n        signOut() {\n          if (imsHack && imsHack.isSignedInUser()) {\n            imsHack.signOut();\n          }\n        },\n        getIMSClientId() {\n          if (imsHack) {\n            return imsHack.adobeIdData.client_id;\n          } else {\n            return null;\n          }\n        }\n      }\n    });\n\n    connection.promise.then((child) => {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n      setChild(child);\n    });\n\n    // Notify that the connection is ready and the iframe src may be set\n    setConnectionReady(true);\n\n    return connection;\n  };\n\n  return (\n    <>\n      <iframe\n        title=\"Main content\"\n        ref={iframe}\n        src={connectionReady ? iframeSrc : ''}\n        css={css`\n          display: block;\n          height: ${height};\n          width: 100%;\n          border: none;\n        `}\n      />\n      <Footer />\n    </>\n  );\n};\n\nFrame.propTypes = {\n  src: PropTypes.string,\n  height: PropTypes.string,\n  location: PropTypes.object\n};\n\nexport default Frame;\n"],"names":["Resolution","ErrorCode","NativeErrorName","MessageType","NativeEventType","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","name","message","stack","id","keyPathToSegments","keyPath","split","setAtKeyPath","subject","value","segments","reduce","prevSubject","key","idx","length","methods","prefix","flattenedMethods","Object","keys","forEach","push","join","segmentsToKeyPath","createKeyPath","assign","callSender","info","methodKeyPaths","destroyConnection","log","localName","local","remote","originForSending","originForReceiving","destroyed","createMethodProxy","methodName","args","iframeRemoved","closed","e","error","Error","code","ConnectionDestroyed","Promise","resolve","reject","generateId","handleMessageEvent","event","source","data","penpal","Reply","origin","replyMessage","removeEventListener","Message","returnValue","returnValueIsError","obj","deserializedError","deserializeError","resolution","Fulfilled","addEventListener","callMessage","Call","postMessage","api","deserializeMethods","serializedMethods","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","receiverMethodName","methodNames","destroyCallSender","options","iframe","timeout","debug","console","callbacks","callback","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","getOriginFromSrc","handleSynMessage","synAckMessage","SynAck","handleSynMessageFactory","handleAckMessage","handleAckMessageFactory","promise","stopConnectionTimeout","timeoutId","undefined","setTimeout","ConnectionTimeout","clearTimeout","handleMessage","contentWindow","Syn","Ack","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","_ref","height","useRef","ims","isLoadingIms","useContext","Context","imsHack","child","setChild","useState","connectionReady","setConnectionReady","useEffect","current","clientHeight","onHide","onShow","pathname","adobeIMS","connection","createConnection","iframeSrc","isExternalLink","withPrefix","connectToChild","URL","scrollTop","position","_document","scrollingElement","getURL","_window","_window$location","href","setURL","url","_window2","setHeight","style","getIMSAccessToken","_imsHack","isSignedInUser","getAccessToken","getIMSProfile","_imsHack2","getProfile","signIn","signOut","getIMSClientId","adobeIdData","client_id","___EmotionJSX","React","title","ref","css","Footer"],"sourceRoot":""}